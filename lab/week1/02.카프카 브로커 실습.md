# Kafka + Zookeeper 도커 세팅 및 CLI 실습

Zookeeper와 Kafka를 Docker Compose로 구성하고, CLI를 통해 토픽을 생성하고 메시지를 송수신하는 과정 실습 입니다.  

M 시리즈 맥북에서 ARM64 기반 bitnami 이미지로 실습

---

## 1. docker-compose.yml 구성

```yaml
version: '3'
services:
  zookeeper:
    image: zookeeper:3.5.9
    container_name: zookeeper
    ports:
      - "2181:2181"
    environment:
      ZOO_CLIENT_PORT: 2181

  kafka:
    image: bitnami/kafka:3.5
    container_name: kafka
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://127.0.0.1:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      ALLOW_PLAINTEXT_LISTENER: "yes"
    depends_on:
      - zookeeper
```

### 각 항목 설명

- `ZOO_CLIENT_PORT`: Zookeeper가 클라이언트 요청을 받을 포트. 기본값은 2181이며 Kafka와 zkCli.sh가 여기에 연결된다.
- `KAFKA_BROKER_ID`: Kafka 클러스터에서 고유한 브로커 ID
- `KAFKA_ZOOKEEPER_CONNECT`: Zookeeper 주소. Kafka는 메타데이터를 저장하기 위해 Zookeeper에 연결한다
- `KAFKA_ADVERTISED_LISTENERS`: Kafka가 클라이언트에게 자신을 알리는 주소. 이 값이 실제 Kafka 접속 주소가 된다
- `KAFKA_LISTENERS`: 브로커가 내부적으로 수신하는 포트 설정
- `KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR`: Kafka 내부 토픽의 복제 수. 단일 브로커에선 반드시 1이어야 한다. (1개밖에 없으면, 복제를 수행할 브로커가 없어, "Not enough in-sync replicas" 오류 발생)
- `ALLOW_PLAINTEXT_LISTENER`: PLAINTEXT 프로토콜을 명시적으로 허용 (bitnami 이미지에선 필요)

---

## 2. 컨테이너 실행

```bash

docker-compose up -d
```

Zookeeper와 Kafka 컨테이너가 각각 2181, 9092 포트로 열림

---

## 3. Kafka CLI 실습

### 3-1. Kafka 내부 CLI 접근

```bash

docker exec -it kafka bash
```

### 3-2. 토픽 생성

```bash

kafka-topics.sh --create \
  --bootstrap-server localhost:9092 \
  --replication-factor 1 \
  --partitions 1 \
  --topic test-topic
```

#### 동작 설명

- `--bootstrap-server`: Kafka 브로커와 초기 연결을 담당
- `--replication-factor`: 복제 수. 단일 브로커에서는 반드시 1
- `--partitions`: 파티션 수. Kafka는 각 토픽을 여러 파티션으로 나눔
- `--topic`: 생성할 토픽 이름

---

### 3-3. 토픽 목록 조회

```bash

kafka-topics.sh --list --bootstrap-server localhost:9092
```

---

### 3-4. 메시지 전송

```bash

kafka-console-producer.sh --broker-list localhost:9092 --topic test-topic
```

- 실행 후 입력한 문자열이 토픽에 전송됨
- 입력 예시:
  ```
  hello
  world
  ```

---

### 3-5. 메시지 소비

```bash

kafka-console-consumer.sh \
  --bootstrap-server localhost:9092 \
  --topic test-topic \
  --from-beginning
```

- 해당 토픽의 메시지를 처음부터 소비함
- Consumer는 기본적으로 group에 소속되지 않으면 offset을 개별 추적하지 않음

---

## 4. Kafka 동작 매커니즘 정리

### 4-1. Kafka와 Zookeeper의 관계

- Kafka는 2.x 버전까지 Zookeeper를 통해 클러스터 상태를 관리
- 브로커 등록, 컨트롤러 선출, 토픽 메타데이터 저장 등에 사용
- Kafka 3.x 이후에는 KRaft 모드(Zookeeper 제거)가 도입됨

### 4-2. 브로커와 클라이언트

- 클라이언트는 `ADVERTISED_LISTENERS`로 브로커 주소를 전달받음
- 브로커는 해당 주소를 기반으로 데이터 송수신

### 4-3. 파티션과 복제

- 하나의 토픽은 여러 파티션으로 나뉘며, 각 파티션은 순서 보장이 됨
- 복제는 고가용성을 위한 메커니즘이며, 단일 브로커에서는 의미 없음

### 4-4. Offset과 Consumer Group

- Consumer는 offset을 기반으로 메시지를 읽음
- Consumer Group으로 묶인 경우, 동일한 파티션을 여러 Consumer가 공유하지 않도록 조정됨

---

## 5. 확인 포인트

- `kafka-topics.sh`로 토픽 생성 여부를 반드시 확인할 것
- `localhost:9092`가 Kafka의 내부 및 외부 통신 주소로 적절히 설정되었는지 확인
- 메시지를 보냈다면 `--from-beginning` 옵션으로 정확히 소비되는지 확인

---

## 6. 정리

```bash

# 컨테이너 실행
docker-compose up -d

# Kafka CLI 접속
docker exec -it kafka bash

# 토픽 생성
kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test-topic

# 메시지 전송
kafka-console-producer.sh --broker-list localhost:9092 --topic test-topic

# 메시지 수신
kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test-topic --from-beginning
```

---


